---
layout: post
title: "Understanding built-in IoC container"
date: 2020-05-12 10:03:01+0800
categories:
  - CSharp-ASP.NET Core
tags:
navi-enable-csharpaspnetcore: true
navi-name: 'Understanding built-in IoC container'
navi-order: 'a1-4-2'
toc: false
toc_label: "TABLE OF CONTENTS"
toc_icon: "cog"
comments: true
description: the working mechanism behind dependency injection.
excerpt: the working mechanism behind dependency injection.
---
<!--navigation bar-->
<div class='navi-link-container'>
  {% assign posts = site.posts|sort:'navi-order' %}
  {% for post in posts %}
    {% if post.navi-enable-csharpaspnetcore %}
        {% if post.navi-order == "a1" or 
              post.navi-order == "a1-4" %}
            <a href="{{ site.baseurl }}{{ post.url }}" class='navi-link'>{{post.navi-name}}</a>
        {%endif%}
    {% endif %}
  {% endfor %}
<a class='navi-link' href="">{{page.navi-name}}</a>
</div>
<!--navigation bar-->

<!-- 获取 serviceprovider from App,ihost,servicecollection,httpcontext-->
<!-- 几个重要的接口 和 类 -->
In this article, we are going dive into the built-in IoC container. In the previous article, we have the following code.

```c#
public void ConfigureServices(IServiceCollection services)
{
  services.AddTransient<ConsoleLog>();//transient
}
```

As you have already known that the `IServiceCollection` is the place for register services. But, where is the place to retrieve services? The answer is `IServiceProvider`. 

There have two types of assemblies, which are `Microsoft.Extensions.DependencyInjection.Abstractions` and `Microsoft.Extensions.DependencyInjection`. The previous one define interfaces, and another implement that. The following is a diagram illustrating the working mechanism.

![Alt][1]

As we can see from the above diagram, the `ServiceProvider` ([link][2]) depends on the `IEnumerator<ServiceDescriptor>`, which generated by the `GetEnumerator` method in `ServiceCollection`([link][3]), where is the place registers our service. 

The `IServiceProviderEngine` instance implements the logic behind it in `ServiceProvider`, and the `IServiceProviderEngine` has a lot of implementation classes. Each implementation has a different performance.

Now, we understand the working mechanism. <span style='color: red;'>Put our services into IServiceCollection, retrieve them back from IServiceProvider</span>. As the `ServiceCollection` constructors are public, so it's easy for us to get its instance. We can new a ServiceCollection instance, or directly use it in `ConfigureServices()` in the *ASP.NET Core* application.

*Startup.cs*
```c#
public class Startup{
  public void ConfigureServices(IServiceCollection services){
    //some operations
  }
}
```
The ServiceProvider constructor is an internal access modifier, so we can't instance it. So, how can we get the ServiceProvider instance?

We can't directly new a ServiceProvider instance. But, Microsoft provides many extension methods to retrieve the ServiceProvider instance. The following lists some ways for that.

**get IServiceProvider through IServiceCollection**
```c#
public class Startup{
  public void ConfigureServices(IServiceCollection services)
  {
    IServiceProvider provider = services.BuildServiceProvider();
    //T service = provider.getService<T>();
  }
}
```

**get IServiceProvider through HttpContext**
```c#
public class CustomController : Controller
{
  public IActionResult Index()
  {
    IServiceProvider provider = HttpContext.RequestServices;
    //T service = provider.getService<T>();
    return View();
  }
}
```

**get IServiceProvider through IApplicationBuilder**
```c#
public class Startup{
  public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
  {
    IServiceProvider provider = app.ApplicationServices;
    //T service = provider.getService<T>();
  }
}
```

**get IServiceProvider through IHost**
```c#
public class Program
{
  public static void Main(string[] args)
  {
    IHost host = CreateHostBuilder(args).Build();
    IServiceProvider provider = host.Services;
    //T service = provider.getService<T>();
    host.Run();
  }
  public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
}
```

Because we can get IServiceProvider from IServiceCollection, and IServiceCollection has a public constructor. So, built-in DI also can be used in non-ASP applications. [Here][4] is an example that illustrates how to use built-in DI in a *.NET Core* Console application.



[1]: /public/img/2020-05-12-understanding-built-in-ioc-container-a.png
[2]: https://source.dot.net/#Microsoft.Extensions.DependencyInjection/ServiceProvider.cs
[3]: https://source.dot.net/#Microsoft.Extensions.DependencyInjection/ServiceCollection.cs,beaaadffb389924e
[4]: https://github.com/voltwu/C-Sharp-Console-Application-NET-CORE-Built-In-Dependency-Injection-Example
